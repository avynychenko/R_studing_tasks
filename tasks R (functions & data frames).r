# R задачи

#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.


find_closest <- function(v, n) {
which(abs(v-n) == min(abs(v-n)))
}

#Построим зиккурат! Напишите функцию, которая принимает одно целое число n, а возвращает “ступенчатую” матрицу, 
#состоящую из n этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

build_ziggurat <- function(n) {
  m <- matrix(1, (2*n-1), (2*n-1))
  if (n == 1) { print(m)}
  else {
  for (i in (n-1):1) {
  m[(n-i):(n+i), (n-i):(n+i)] <- n-i }
  m[n, n] <- n
  m }
}

#Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите 
#все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) 
#этих элементов.

count_elements <- function(x) {
m <- matrix(NA, 2, length(unique(x)))
  m[1, ] <- sort(unique(x))
  m[2, ] <- matrix(table(x))
  m
}


#Дата фрейм attitude -- встроенный массив данных, содержащий рейтинг департаментов одной финансовой компании, составленный сотрудниками. Представьте, что вы хотите устраиваться как раз в эту компанию, и дата фрейм (совершенно случайно!) оказался в вашем распоряжении. 
# Вы решили, что самое главное для вас -- это возможность учиться новому (learning). Возьмите 5 топовых департаментов по этому показателю. Из этого набора вам более всего подойдёт тот департамент, который имеет наибольшую сумму баллов по трём показателям: реакция на жалобы работников (complaints), надбавки в зависимости от результатов работы (raises) и возможность продвижения (advance).

# Какой же департамент вам выбрать? Напишите его номер XX

z <- sort(attitude$learning, decreasing = T)
y <- subset(attitude, learning %in% head(z, 5), select = c(complaints, raises, advance))
which.max(rowSums(y))


# #добавление датафрейма (что попало там, с комментами и т.д.)по вот этой ссылке https://github.com/tonytonov/Rcourse/blob/master/R%20programming/avianHabitat2.csv
# к действующему нормальному датафрейму под названием avlan

avlan <- read.csv("C:/Users/Nastya/Desktop/avianHabitat_sewardPeninsula_McNew_2012/avianHabitat_sewardPeninsula_McNew_2012.csv")

data2 <- read.csv2("C:/Users/Nastya/Desktop/avianHabitat_sewardPeninsula_McNew_2012/avianHabitat2.csv",
                   header = F, sep = ';', dec = ".", skip = 5, na.strings = "Don't remember", comment.char = "%")

x <- as.matrix(data2[1, ])
y <- as.vector(x)
y[length(y)] <- "PB" #в названии этого столбца был пробел после РВ, поэтому этим действием мы его удалили
colnames(data2) <- y # приобразование первой строки датафрейма в вектор с типом chr

data_clean <- data2[-1, ]
data_clean$Observer <- "CL"         #добавили недостающую колонку и информацией об исследователе
data_clean <- type.convert(data_clean)   # привели данные к нормальному типу

str(data_clean)

new_df <- rbind(avlan, data_clean)   # объединили датафреймы по строкам
summary(new_df)

# подсчёт общего покрытия в новом датафрейме, добавив переменную total_coverage. В качестве ответа указать величину среднего покрытия с точностью до второго знака: X.XX 

new_df$total_coverage <- rowSums(new_df[-(1:4)] [c(T, F)])
mean(new_df$total_coverage)

#ответ 9.57

#задание, по которому я так и не смогла засабмитить потому, что нигде нет соотношения названия растений к данным
#На массиве avianHabitat найдите максимальные высоты по каждому виду растений и отсортируйте эти виды по убыванию, от самого высокого к самому низкому.
avianHabitat <- new_df[-(1:5)][c(T, F)][-17]
avianHabitat$max_height <- apply(avianHabitat, 1, max) #функция считает мах значение в каждой строчке
z <- avianHabitat[order(avianHabitat$max_height, decreasing = T),] #сортирует по убыванию
