#Постройте зиккурат! Напишите функцию, которая принимает одно целое число n, а возвращает “ступенчатую” матрицу, 
#состоящую из n этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

build_ziggurat <- function(n) {
  m <- matrix(1, (2*n-1), (2*n-1))
  if (n == 1) { print(m)}
  else {
  for (i in (n-1):1) {
  m[(n-i):(n+i), (n-i):(n+i)] <- n-i }
  m[n, n] <- n
  m }
}

# Напишите функцию filtered.sum, которая на вход получает вектор с пропущенными, положительными и отрицательными значениями и 
#возвращает сумму положительных элементов вектора.

filtered.sum <- function(x) {
  y <- x[x >= 0 & !is.na(x)]
  return(sum(y))
}

# Напишите функцию outliers.rm, которая находит и удаляет выбросы. Выбросами будем считать те наблюдения, которые отклоняются от 1 
#или 3 квартиля больше чем на 1,5 *  IQR, где  IQR  - межквартильный размах. На вход функция получает числовой вектор x. Функция должна 
#возвращать модифицированный вектор x с удаленными выбросами. 

outliers.rm <- function(x) {
  for(i in 1:length(x)) {
    first_qtl <- quantile(x, probs = c(0.25, 0.75))[1] - 1.5*IQR(x)
    third_qtl <- quantile(x, probs = c(0.25, 0.75))[2] + 1.5*IQR(x)
    if (x[i] > third_qtl | x[i] < first_qtl) {
      x[c(-which(x > third_qtl), -which(x < first_qtl))]
      } 
  } 
  return(x[c(-which(x > third_qtl), -which(x < first_qtl))])
  }

#Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите 
#все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) 
#этих элементов.

#можно было просто сделать через функцию table(), но они хотели матрицу

count_elements <- function(x) {
m <- matrix(NA, 2, length(unique(x)))
  m[1, ] <- sort(unique(x))
  m[2, ] <- matrix(table(x))
  m
}

#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.

find_closest <- function(v, n) {
which(abs(v-n) == min(abs(v-n)))
}


# Напишите функцию NA.counter для подсчета пропущенных значений в векторе.

NA.counter <- function(x) {
  return(sum(is.na(x)))
}

# Напишите функцию, которая выводит номера позиций пропущенных наблюдений в векторе.

na_in_vector <- function(x) {
  which(is.na(x) == TRUE)
}