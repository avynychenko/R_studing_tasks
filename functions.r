#Постройте зиккурат! Напишите функцию, которая принимает одно целое число n, а возвращает “ступенчатую” матрицу, 
#состоящую из n этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

build_ziggurat <- function(n) {
  m <- matrix(1, (2*n-1), (2*n-1))
  if (n == 1) { print(m)}
  else {
  for (i in (n-1):1) {
  m[(n-i):(n+i), (n-i):(n+i)] <- n-i }
  m[n, n] <- n
  m }
}

#  Написать функцию get_important_cases, которая принимает на вход dataframe с произвольным числом количественных переменных 
# (гарантируется хотя бы две переменные). Функция должна возвращать dataframe с новой переменной - фактором important_cases.
# Переменная  important_cases принимает значение Yes, если для данного наблюдения больше половины количественных переменных 
# имеют значения больше среднего. В противном случае переменная important_cases принимает значение No.

get_important_cases <- function(x) {
  logic <- apply(x, 2, function(i) i > mean(i))
  if (ncol(x) %% 2 == 1) {
    x$important_cases <- factor(ifelse(rowSums(logic) >= (ncol(logic)/2 + 0.5), "Yes", "No"), 
                                levels = c("No", "Yes"))
  } else {
    x$important_cases <- factor(ifelse(rowSums(logic) > (ncol(logic)/2), "Yes", "No"),
                                levels = c("No", "Yes"))
  }
  return(x)
}

# Напишите функцию filtered.sum, которая на вход получает вектор с пропущенными, положительными и отрицательными значениями и 
#возвращает сумму положительных элементов вектора.

filtered.sum <- function(x) {
  y <- x[x >= 0 & !is.na(x)]
  return(sum(y))
}

# Напишите функцию outliers.rm, которая находит и удаляет выбросы. Выбросами будем считать те наблюдения, которые отклоняются от 1 
#или 3 квартиля больше чем на 1,5 *  IQR, где  IQR  - межквартильный размах. На вход функция получает числовой вектор x. Функция должна 
#возвращать модифицированный вектор x с удаленными выбросами. 

outliers.rm <- function(x) {
  for(i in 1:length(x)) {
    first_qtl <- quantile(x, probs = c(0.25, 0.75))[1] - 1.5*IQR(x)
    third_qtl <- quantile(x, probs = c(0.25, 0.75))[2] + 1.5*IQR(x)
    if (x[i] > third_qtl | x[i] < first_qtl) {
      x[c(-which(x > third_qtl), -which(x < first_qtl))]
      } 
  } 
  return(x[c(-which(x > third_qtl), -which(x < first_qtl))])
  }

#Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите 
#все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) 
#этих элементов.

#можно было просто сделать через функцию table(), но они хотели матрицу

count_elements <- function(x) {
m <- matrix(NA, 2, length(unique(x)))
  m[1, ] <- sort(unique(x))
  m[2, ] <- matrix(table(x))
  m
}

#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.

find_closest <- function(v, n) {
which(abs(v-n) == min(abs(v-n)))
}

# Напишите функцию stat_mode, которая получает на вход вектор из чисел произвольной длины и возвращает числовой вектор с 
# наиболее часто встречаемым значением. Если наиболее часто встречаемых значений несколько, функция должна возвращать несколько 
# значений моды  в виде числового вектора. 

stat_mode <- function(x) {
  as.numeric(names(which(table(x) == max(table(x)))))
}

# Напишите функцию NA.counter для подсчета пропущенных значений в векторе.

NA.counter <- function(x) {
  return(sum(is.na(x)))
}

# Напишите функцию, которая выводит номера позиций пропущенных наблюдений в векторе.

na_in_vector <- function(x) {
  which(is.na(x) == TRUE)
}