#Постройте зиккурат! Напишите функцию, которая принимает одно целое число n, а возвращает “ступенчатую” матрицу, 
#состоящую из n этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

build_ziggurat <- function(n) {
  m <- matrix(1, (2*n-1), (2*n-1))
  if (n == 1) { print(m)}
  else {
  for (i in (n-1):1) {
  m[(n-i):(n+i), (n-i):(n+i)] <- n-i }
  m[n, n] <- n
  m }
}

# Напишите фуекцию для честной и нечестной рулетки. Честная -- это когда все имеющиеся значения (всего их 37) выпадают с равной 
# вероятностью. А нечестная пусть выдаёт все значения, кроме зеро, с равной вероятностью. Что же касается зеро, то вероятность 
# его выпадения пусть будет в два раза больше, чем любого другого значения. 

 generator <- function(set, prob = rep(1/length(set), length(set))) { 
  if (prob == rep(1/length(set), length(set))) {
    function(n) sample(set, n, prob, replace = T)
  } else {
    prob =c(2/(length(set) + 1), rep(1/(length(set) + 1), (length(set) - 1)))
    function(n) sample(set, n, prob, replace = T)
  }
}

roulette_values <- c("Zero!", 1:36)
fair_roulette <- generator(roulette_values)
rigged_roulette <- generator(roulette_values, prob = 0.2)

# Написать бинарный оператор. Пусть %+% действует на два числовых вектора, складывая их поэлементно, но без учёта правил 
# переписывания: если длина векторов различна, то возвращаем вектор большей длины, но с пропущенными значениями в конце.

"%+%" <- function(x, y) {
    n <- max(length(x), length(y))
    length(x) <- length(y) <- n
    x + y
}

#  Написать функцию get_important_cases, которая принимает на вход dataframe с произвольным числом количественных переменных 
# (гарантируется хотя бы две переменные). Функция должна возвращать dataframe с новой переменной - фактором important_cases.
# Переменная  important_cases принимает значение Yes, если для данного наблюдения больше половины количественных переменных 
# имеют значения больше среднего. В противном случае переменная important_cases принимает значение No.

get_important_cases <- function(x) {
  logic <- apply(x, 2, function(i) i > mean(i))
  if (ncol(x) %% 2 == 1) {
    x$important_cases <- factor(ifelse(rowSums(logic) >= (ncol(logic)/2 + 0.5), "Yes", "No"), 
                                levels = c("No", "Yes"))
  } else {
    x$important_cases <- factor(ifelse(rowSums(logic) > (ncol(logic)/2), "Yes", "No"),
                                levels = c("No", "Yes"))
  }
  return(x)
}

# Составьте вектор cat_catalogue, содержащий всевозможные комбинации имеющихся характеристик, и отсортируйте его. Допустим, я 
# хочу завести кота. Тогда я беру случайное число, скажем, 42, и выбираю запись под этим номером. Что за кот мне достался? 

cat_temper <- c("задиристый", "игривый", "спокойный", "ленивый")
cat_color <- c("белый", "серый", "чёрный", "рыжий")
cat_age <- c("кот", "котёнок")
cat_trait <- c("с умными глазами", "с острыми когтями", "с длинными усами")

# решение:

cat_catalogue <- expand.grid(cat_temper, cat_color, cat_age, cat_trait)   # создаем df со всевозможными комбинациями
data <- as.vector(cat_catalogue)
data_cor <- mapply(paste, data[1], data[2], data[3], data[4])
stri_sort(data_cor)[42]



# Напишите функцию filtered.sum, которая на вход получает вектор с пропущенными, положительными и отрицательными значениями и 
#возвращает сумму положительных элементов вектора.

filtered.sum <- function(x) {
  y <- x[x >= 0 & !is.na(x)]
  return(sum(y))
}

# Напишите функцию outliers.rm, которая находит и удаляет выбросы. Выбросами будем считать те наблюдения, которые отклоняются от 1 
#или 3 квартиля больше чем на 1,5 *  IQR, где  IQR  - межквартильный размах. На вход функция получает числовой вектор x. Функция должна 
#возвращать модифицированный вектор x с удаленными выбросами. 

outliers.rm <- function(x) {
  for(i in 1:length(x)) {
    first_qtl <- quantile(x, probs = c(0.25, 0.75))[1] - 1.5*IQR(x)
    third_qtl <- quantile(x, probs = c(0.25, 0.75))[2] + 1.5*IQR(x)
    if (x[i] > third_qtl | x[i] < first_qtl) {
      x[c(-which(x > third_qtl), -which(x < first_qtl))]
      } 
  } 
  return(x[c(-which(x > third_qtl), -which(x < first_qtl))])
  }

#Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите 
#все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) 
#этих элементов.

#можно было просто сделать через функцию table(), но они хотели матрицу

count_elements <- function(x) {
m <- matrix(NA, 2, length(unique(x)))
  m[1, ] <- sort(unique(x))
  m[2, ] <- matrix(table(x))
  m
}

#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.

find_closest <- function(v, n) {
which(abs(v-n) == min(abs(v-n)))
}

# Напишите функцию stat_mode, которая получает на вход вектор из чисел произвольной длины и возвращает числовой вектор с 
# наиболее часто встречаемым значением. Если наиболее часто встречаемых значений несколько, функция должна возвращать несколько 
# значений моды  в виде числового вектора. 

stat_mode <- function(x) {
  as.numeric(names(which(table(x) == max(table(x)))))
}

# Напишите функцию NA.counter для подсчета пропущенных значений в векторе.

NA.counter <- function(x) {
  return(sum(is.na(x)))
}

# Напишите функцию, которая выводит номера позиций пропущенных наблюдений в векторе.

na_in_vector <- function(x) {
  which(is.na(x) == TRUE)
}